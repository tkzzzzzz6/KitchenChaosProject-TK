# 墙壁滑动详细说明

## 什么是"墙壁滑动"？

在这个Kitchen Chaos项目中，"墙壁滑动"实际上是指**Counter碰撞滑动**。

虽然游戏中没有传统意义上的墙壁，但Counter、桌子等物体都有碰撞体(Collider)，会阻挡玩家移动。

---

## 碰撞检测的工作原理

### 相关代码位置
- `Player.cs:15` - `counterLayerMask` 定义哪些物体会阻挡玩家
- `Player.cs:235-251` - `CanMove()` 方法使用CapsuleCast检测碰撞

### counterLayerMask的双重作用

```csharp
[SerializeField] private LayerMask counterLayerMask;
```

这个mask在两个地方使用：

1. **交互检测** (`HandleInteraction`):
   - 检测玩家面前有哪个Counter可以交互
   - 显示选中效果

2. **碰撞检测** (`CanMove`):
   - 检测玩家是否会撞上Counter等物体
   - 阻止玩家穿透Counter

---

## 问题：原始行为的卡顿

### 场景1：走向Counter角落
```
厨房布局：
┌─────────┬─────────┐
│ Counter │ Counter │
└─────────┴─────────┘

玩家从斜角接近：
         ↘ Player
┌─────────┬─────────┐
│ Counter │ Counter │
└─────────┴─────────┘

原始行为：
❌ 卡在角落，无法继续移动
❌ 必须后退，调整角度，再前进
```

### 场景2：沿着Counter边缘移动
```
玩家想沿着Counter侧面走：
    Player →
┌──────────────┐
│   Counter    │
└──────────────┘

原始行为：
❌ 如果角度稍微偏向Counter，就会卡住
❌ 必须完全水平移动才能通过
```

---

## 改进：滑动机制

### 滑动原理

当玩家移动方向会撞上Counter时：

1. **检测碰撞**: CapsuleCast检测到前方有Counter
2. **获取法线**: 获取Counter表面的法线向量（垂直于表面的方向）
3. **投影方向**: 将玩家的移动方向投影到Counter表面
4. **沿表面滑动**: 玩家沿着投影后的方向移动

### 数学原理
```
原始移动方向：  ↘
Counter法线：    ←⊥
投影后方向：    ↓ (沿着Counter边缘)
```

### 代码实现
```csharp
private Vector3 CalculateWallSliding(Vector3 direction, float distance)
{
    RaycastHit hit;
    // 检测碰撞
    if (Physics.CapsuleCast(..., out hit, ...))
    {
        // 获取碰撞面法线
        Vector3 normal = hit.normal;
        normal.y = 0; // 保持水平滑动

        // 将移动方向投影到表面
        Vector3 slideDirection = Vector3.ProjectOnPlane(direction, normal).normalized;
        return slideDirection;
    }
}
```

---

## 实际游戏场景示例

### 场景1：在多个Counter之间移动
```
厨房布局：
┌──────┐    ┌──────┐
│ 切菜台│    │炉灶台│
└──────┘    └──────┘
    ↑           ↑
  Player想从这里走到那里

没有滑动：
- 如果角度不对，会卡在Counter边缘
- 需要精确控制方向

有滑动：
- 斜着走也能自动绕过Counter
- 自然流畅的移动
```

### 场景2：拥挤的厨房
```
复杂布局：
┌──────┬──────┬──────┐
│Counter│Counter│Counter│
└──────┴───┬──┴──────┘
           │狭窄通道
           ↑ Player

没有滑动：
- 很难通过狭窄通道
- 容易卡在入口

有滑动：
- 即使角度不完美也能进入
- 自动调整方向贴着边缘走
```

---

## 如何测试滑动效果

### 测试步骤：

1. **打开游戏场景**
   - 找到一个Counter（例如CuttingCounter）

2. **测试无滑动行为**（对比）
   - 在Inspector中找到Player对象
   - 取消勾选 `Enable Wall Sliding`
   - 运行游戏
   - 以45度角走向Counter
   - **结果**：会卡住或停止

3. **测试有滑动行为**
   - 勾选 `Enable Wall Sliding`
   - 运行游戏
   - 以45度角走向Counter
   - **结果**：自动沿着Counter边缘滑动

4. **测试狭窄空间**
   - 在两个Counter之间行走
   - 观察是否能流畅通过

---

## 技术细节

### 为什么叫"墙壁"滑动？

这是游戏开发中的通用术语：
- 源自FPS游戏（如Half-Life, Quake）
- 玩家沿着墙壁表面滑动
- 在这个项目中，Counter = 墙壁的角色

### 与原有X/Z轴分离的关系

代码中保留了原有的X/Z轴分离逻辑作为后备：

```csharp
if (!canMove)
{
    // 1. 首先尝试滑动（新）
    if (enableWallSliding) { ... }

    // 2. 滑动失败，尝试X轴（原有）
    if (CanMove(moveDirX, ...)) { ... }

    // 3. X轴也不行，尝试Z轴（原有）
    if (CanMove(moveDirZ, ...)) { ... }
}
```

这样保证了：
- 优先使用更自然的滑动
- 滑动不适用时，仍有原始逻辑兜底
- 向后兼容

---

## 视觉对比

### 原始行为：
```
Input: ↘ (东南方向)
  ╔═══════╗
  ║Counter║ ← 碰撞检测到
  ╚═══════╝

Result: 停止移动 ⛔
```

### 滑动行为：
```
Input: ↘ (东南方向)
  ╔═══════╗
  ║Counter║ ← 碰撞检测到
  ╚═══════╝
    ↓ 投影到表面

Result: 向下滑动 ⬇ ✅
```

---

## 为什么这个改进很重要？

### 1. 提升玩家体验
- 不需要精确控制角度
- 移动更流畅自然
- 减少卡顿和挫败感

### 2. 符合玩家直觉
- 现实中人走路不会因为角度问题卡住
- 会自然地贴着障碍物边缘走

### 3. 适合快节奏游戏
- Kitchen Chaos是快节奏烹饪游戏
- 不应该在移动上浪费时间
- 应该专注于烹饪任务

---

## 总结

- "墙壁滑动" = "Counter碰撞滑动"
- 让玩家贴着Counter边缘自然移动
- 解决了卡顿和角度问题
- 是现代游戏的标准机制
- 完全可选，可随时开关

**建议保持启用，除非你想要更硬核的移动体验！** 🎮
